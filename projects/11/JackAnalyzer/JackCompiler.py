import sys, os, json
import xml.etree.ElementTree as ET
import JackAnalyzer, CompilationEngine, SymbolTable, VMWriter

class JackCompiler():
    def __init__(self):
        self.jackAnlyzr = JackAnalyzer.JackAnalyzer()
        self.table = None
        self.vmWriter = None

    def compile(self, path):
    #prcess the pretty print xml file that generated by CompilationEngine
        if os.path.isdir(path):
            for filename in os.listdir(path):
                if filename.endswith(CompilationEngine.PRETTY_PRINT_FILE):
                    print('Convert xml to vm code: {}'.format(os.path.join(path, filename)))
                    self._process_xml_file(os.path.join(path, filename))
        elif os.path.isfile(path):
            path = path.replace('.jack', CompilationEngine.PRETTY_PRINT_FILE)
            if not os.path.isfile(path):
                print('Can not find {}'.format(path))
                exit()
            print('Convert xml to vm code: {}'.format(path))
            self._process_xml_file(path)
        else:
            print("'{}' is not a valid path".format(path))

    def _process_xml_file(self, src):
        self.vmWriter = VMWriter.VMWriter(src.replace(CompilationEngine.PRETTY_PRINT_FILE, '.vm'))

        src_tree = ET.ElementTree(file=src)
        self.table = SymbolTable.SymbolTable()

        print('---------global table------------')
        self._build_global_table(src_tree)
        #print(json.dumps(self.table.table ,sort_keys=True, indent=4))

        subroutineDecs = src_tree.findall('./subroutineDec')
        className = src_tree.findall('./')[1].text
        for dec in subroutineDecs:
            print('---------local table: {}------------'.format(dec.findall('./')[2].text))
            self._build_local_table(dec, className)
            #print(json.dumps(self.table.subroutine_table.table ,sort_keys=True, indent=4))
            self._gen_vm_code(className, dec)
        
        self.vmWriter.close()

    def _build_global_table(self, src_tree):
        classVarDec = src_tree.findall('./classVarDec')
        for e in classVarDec:
            dec = e.findall('./')
            idx = 2
            while idx < len(dec):
                self.table.define(dec[idx].text, dec[1].text, dec[0].text)
                idx += 2

    def _build_local_table(self, dec_tree, className):
        #Add this to subroutine table
        if dec_tree.findall('./')[0].text == 'method':
            self.table.define('this', className,'arg')

        #add parameters to subroutine table
        parameterList_elements = dec_tree.findall('./parameterList/')
        if parameterList_elements:
            idx = 0
            while idx < len(parameterList_elements):
                self.table.define(parameterList_elements[idx+1].text, parameterList_elements[idx].text, 'arg')
                idx += 3

        #add variables to subroutine table
        varDec_elements = dec_tree.findall('./subroutineBody/varDec')
        for varDec_e in varDec_elements:
            idx = 2
            while idx < len(varDec_e):
                self.table.define(varDec_e[idx].text, varDec_e[1].text, 'var')
                idx += 2

    def _gen_vm_code(self, classNmae, tree):
        tree_e = tree.findall('./')
        #compile function
        self.vmWriter.writeFunction('{}.{}'.format(classNmae, tree_e[2].text), self.table.VarCount('VAR'))

        #compile statements
        statements_e = tree.findall('./subroutineBody/statements/')
        for e in statements_e:
            if e.tag == 'letStatement':
                pass
            elif e.tag == 'ifStatement':
                pass
            elif e.tag == 'whileStatement':
                pass
            elif e.tag == 'doStatement':
                self._compile_do(e)
            elif e.tag == 'returnStatement':
                self._compile_return(e)
            else:
                print('ERROR: invalide statement "{}"'.format(e.tag))

    def _compile_do(self, tree):
        #expressionList
        self._compile_expressionList(tree.find('./expressionList'))

        #function
        idx = 1
        func = ''
        e_lst = tree.findall('./')
        while e_lst[idx].text != '(':
            func += e_lst[idx].text
            idx += 1
        self.vmWriter.writeCall(func, self._cal_call_args( tree.find('./expressionList') ))

        self.vmWriter.writePop('temp', '0')

    def _compile_return(self, return_tree):
        return_void = True
        for e in return_tree:
            if e.tag == 'expression':
                return_void = False
                self._compile_expression(e)

        if return_void:
            self.vmWriter.writePush('constant', 0)

        self.vmWriter.writeReturn()

    def _cal_call_args(self, expressionList_tree):
        count = 1
        for e in expressionList_tree:
            if e.text == ',':
                count += 1
        return count

    def _compile_expressionList(self, expressionList_tree):
        for e in expressionList_tree.findall('./expression'):
            #print(e.tag)
            self._compile_expression(e)

    def _compile_expression(self, expression_tree):
        operator_buf = []
        for e in expression_tree:
            #print(e)
            if e.tag == 'term':
                self._compile_term(e)
            elif e.tag == 'symbol':
                operator_buf.append(e.text)
            else:
                print('Compile expression ERROR: <{}> {}'.format(e.tag, e.text))

        operator_buf.reverse()
        for operator in operator_buf:
            self.vmWriter.writeArithmetic(operator)


    def _compile_term(self, term_tree):
        for e in term_tree:
            if e.tag == 'expression':
                self._compile_expression(e)
            elif e.tag == 'integerConstant':
                self.vmWriter.writePush(self.table.KindOf(e.text), self.table.IndexOf(e.text))

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print('Usage: python JackAnalyzer.py PATH')
        exit()

    jackCompiler = JackCompiler()

    path = sys.argv[1]
    jackCompiler.jackAnlyzr.read_file_or_dir(path)

    jackCompiler.compile(path)